%%%%%%%%% Further Work %%%%%%%%%

\section{Possible Improvements}

The program for the CRIMI takes measurements with the step-integrate method. This introduces waiting time, which can add up to several hours for a precise measurement. To facilitate these kinds of measurements, a fast scan method could be implemented.

\subsection{Fast Scan}
Ideally with the fast scan method the linear stage moves between two specified end points and sends out a trigger pulse when a measurement should be made. At that moment it knows its position and this is sent to the computer, along with the voltage reading from the read-out device. In this way the same amount of data points can be acquired in much less time than is needed for the step integrate method. Even though this data is less precise, with many more data points it does not matter much.

I started working on this, but have not yet managed to synchronize the stage and the read-out device, which is essential to make this method work. In this setup the read-out device was the Agilent 34401A multimeter. The controller for the stage can send the trigger pulses, but the multimeter side does not yet react to these pulses.

\subsection{Improvements to Code}
Even though the step-integrate program works, this does not mean that the code is perfect. In the class for the GUI (\verb!Frame1!) a few too many lines which should be in a separate class slipped in. Especially where the different data files are saved, the GUI code and processing code are too much mixed. This saving process should be completely separated from the GUI.

In the same way in the GUI code the plotting during the measurement is done with different code than the plotting that is done during saving. This could be cleaned up by refactoring this part of the code.

In the \verb!Parameters! class some parameters are converted into different parameters. I tested the correctness by hand for the edge cases I could think of, but it would be better to write a unit test that can do this every time a small change is made in the code. 

Lastly it could be made more clear which methods in a class are private (used only in that class) and which are public (used by collaborating objects). In Python the private methods are marked with two underscores: \_\_\verb!examplemethod()!. This way, these methods cannot be called from outside the class.

%\begin{itemize}
%\item inhoudelijk: fast scan. wat heb ik tot nu toe gedaan, en waar wil ik heen. Was toch wel lastig.
%\item in de code: in het gui-gedeelte: het plotten uitdrukken in de plotmethodes die ik gemaakt heb, ipv dat stukje code `opnieuw' uit te werken.
%\item in de code: tests toevoegen om alle mogelijke manieren van afronden (bijv) te kunnen controleren en dus zeker weten dat dat stukje code doet wat je wilt dat het doet.
%\item nog meer de GUI loskoppelen van het data verwerken, vooral in het opslaangedeelte. Dat had een aparte klasse moeten worden.
%\end{itemize}

%14:03 <marten> of alleen al iets wat dan specifiek "acceptatietest" heet: sluit 
%               alles aan, op een bepaalde (simpelste) configuratie (bijv niet 
%               vacuum), en draai script die je vertelt of het apparaat lijkt te 
%               reageren zoals je dan zou verwachten (binnen bepaalde marges)
%14:04 <marten> dus iets wat niet randgevallen checkt, maar juist kijkt of alles 
%               in het simpelste geval nog werkt
%14:04 <marten> dat kun je dan ook gebruiken om te kijken of er geen motoren 
%               stuk zijn gegaan na een jaar op de plank
%14:04 <marten> en of je alles correct hebt aangesloten
%14:05 <marten> met het idee dat als die test slaagt, dat je dan m kunt gaan 
%               gebruiken voor je specifiek gewenste setup
%14:05 <marten> en met redelijke zekerheid kunt zeggen dat je logische 
%               resultaten zult krijgen


