%%%%%%%%% NEW SECTION: STEP-INTEGRATE PROGRAM %%%%%%%%%

\section{Step-Integrate Program}

%Geef hier een blokdiagram van je programma, waarin aangegeven wordt hoe de data wordt ingevoerd, hoe de scan wordt uitgevoerd en hoe de data storage en processing (FFT, WIndowing, complex FFT?) wordt gedaan. Ter verduidelijking van de processing zou je een dummy interferogram (b.v. een top-hat) door je data processing kunnen sturen , om aan te geven wat het effect van de windowing is (en evt. het effect als je niet een correcte zero path hebt)

A measurement is made with the following method:

 \begin{enumerate}
  \item The linear stage takes a step.
  \item The position of the stage is measured.
  \item The program waits for the duration of $3\times$ the integration time as set on the lock in amplifier.
  \item The voltage is measured.
 \end{enumerate}

Every time a data point is acquired, the program has to be idle to let the lock in amplifier settle. This is called the step-integrate method. After the measurement is completed, the data can be saved (see section~\ref{subsub:saving} for more information on saving). A few steps are done during this saving time.

\begin{enumerate}
 \item The raw interferogram data, position and voltages, is saved.
 \item The data is multiplied by a Hann apodization function.
 \item The FFT with and without the Hann apodization function is calculated.
 \item Both FFT data are saved.
\end{enumerate}

The Hann apodization function is implemented using the \verb!hanning! function from the numpy package. The fast Fourier transforms are calculated using the \verb!fft.fft! function also from the numpy package. The absolute value is taken, because the Fourier transform is complex and the data is real.

The maximum frequency is determined by the interval spacing between the points, or stepsize. The Nyquist limit reduces this maximum frequency with a factor of 2. Together with the fact that a step with the stage is multiplied by 4 for the optical path difference, this gives a factor of 8 which should be accounted for in the conversion between the stepsize and the maximum frequency. This is done in the \verb!Parameters! class.

\subsection{Code Overview}\label{sub:codeoverview}

The code consists of a few different classes that talk to the hardware, or do measurements with the returned parameters. The classes \verb!C876_160!, \verb!SR510!, and \verb!EthernetAdapter! do the interaction with the hardware, with the commands as dictated in the corresponding manuals.

The classes \verb!Parameters!, \verb!Plotting!, and \verb!Fourier! interact with the data that comes from the instruments. \verb!ReadoutSession! does the actual measurement steps, and a \verb!NepSession! has been made to test the rest of the code without having to use the actual hardware.

\begin{figure}[h!tb]
 \begin{center}
  \includegraphics[width=\textwidth]{figures/blokdiagram_classes.pdf}
  \caption{The classes in use in the program. The class `NepSession' is for testing purposes only.}
  \label{fig:blokdiagram}
 \end{center}
\end{figure}

The code comes together in the class \verb!Frame1!, where the different actions are coupled to the buttons in the GUI. This class also makes use of the file \verb!gui_stepintegrate.py!, which is the code for the GUI as generated by \verb!wxFormbuilder!. See also figure~\ref{fig:blokdiagram} for an overview. The Python files where the classes can be found are also mentioned.

If a different piece of hardware must be used, a new class can be made with the same structure as the original class. For example a SR530 might communicate differently, but as long as the class keeps the same interface, it can be swapped out with the SR510. In the same way the EthernetAdapter could be switched out by a direct GPIB connection, as long as this connection has a \verb!write_query()! and a \verb!write_command()!.

\subsection{Addresses}
A few addresses have been hardcoded into the software. The stage controller is hardcoded to be on the (virtual) COM~3 port. This can be found in the initialization of the class \verb!C867_160!, where it can be adjusted.

The EthernetAdapter should have host '192.168.11.201' and port 1234, with the ethernet card in the computer the address '192.168.11.200'. This can be changed in the initialization of the class \verb!EthernetAdapter!. Finally the lock in amplifier has to have GPIB address 8, which is also coded in the class \verb!EthernetAdapter!.

